# FPS Overlay 需求文档

## 用户功能需求（核心）

1. **极简显示** - FPS 窗口尽可能小，只显示必要信息
2. **始终置顶** - FPS 显示始终浮在游戏画面之上
3. **完全透明** - 不影响游戏本身画面，无背景遮挡
4. **稳定刷新** - FPS 数值稳定，不频繁跳动
5. **热键切换** - 可通过热键显示/隐藏

---

## 1. 项目概述

### 1.1 项目背景
玩家在游戏过程中需要实时了解游戏性能状态，FPS（帧率）是最核心的性能指标。现有方案如 Fraps、MSI Afterburner、GeForce Experience 等都提供了类似功能，本项目旨在实现一个轻量级、可定制的 FPS 叠加显示工具。

### 1.2 项目目标
开发一个能够在任意 DirectX 游戏上实时显示 FPS 的叠加层程序。

### 1.3 目标用户
- 游戏玩家：监控游戏性能
- 游戏开发者：调试和性能分析
- 硬件评测人员：性能测试

---

## 2. 功能需求

### 2.1 核心功能

| 编号 | 功能 | 优先级 | 描述 |
|------|------|--------|------|
| F-001 | FPS 显示 | P0 | 实时显示当前帧率，精度到小数点后1位 |
| F-002 | 帧时间显示 | P0 | 显示每帧渲染耗时（毫秒） |
| F-003 | DLL 注入 | P0 | 将叠加层 DLL 注入到目标游戏进程 |
| F-004 | 热键控制 | P1 | 支持热键显示/隐藏叠加层（默认 F1） |
| F-005 | 自动附加 | P2 | 监控进程启动，自动注入指定游戏 |

### 2.2 显示功能

| 编号 | 功能 | 优先级 | 描述 |
|------|------|--------|------|
| D-001 | 位置可调 | P1 | 叠加层显示位置可配置（四角 + 自定义坐标） |
| D-002 | 颜色指示 | P1 | FPS 根据数值显示不同颜色（绿/黄/红） |
| D-003 | 透明度 | P2 | 叠加层背景透明度可调 |
| D-004 | 字体大小 | P2 | 显示文字大小可调 |

### 2.3 扩展功能（后续版本）

| 编号 | 功能 | 优先级 | 描述 |
|------|------|--------|------|
| E-001 | GPU 使用率 | P3 | 显示显卡使用率 |
| E-002 | CPU 使用率 | P3 | 显示处理器使用率 |
| E-003 | 温度监控 | P3 | 显示 GPU/CPU 温度 |
| E-004 | 帧时间图表 | P3 | 显示帧时间波动曲线 |
| E-005 | 截图/录制 | P3 | 支持游戏截图和录制 |

---

## 3. 非功能需求

### 3.1 性能要求

| 编号 | 要求 | 指标 |
|------|------|------|
| NFR-001 | CPU 开销 | < 1% CPU 占用 |
| NFR-002 | 内存开销 | < 20MB 内存占用 |
| NFR-003 | 帧率影响 | 对游戏帧率影响 < 1 FPS |
| NFR-004 | 延迟 | FPS 数值更新延迟 < 100ms |

### 3.2 兼容性要求

| 编号 | 要求 | 描述 |
|------|------|------|
| NFR-005 | 操作系统 | Windows 10/11 64位 |
| NFR-006 | 图形API | DirectX 11（首要），DX9/10/12（扩展） |
| NFR-007 | 窗口模式 | 支持全屏、无边框、窗口化模式 |
| NFR-008 | 分辨率 | 支持 720p ~ 4K 分辨率 |

### 3.3 稳定性要求

| 编号 | 要求 | 描述 |
|------|------|------|
| NFR-009 | 崩溃率 | 不应导致游戏崩溃 |
| NFR-010 | 热插拔 | 支持运行时注入和卸载 |
| NFR-011 | 异常处理 | Hook 失败时静默退出，不影响游戏 |

---

## 4. 技术方案选型

### 4.1 整体方案：DLL注入 + Hook

| 方案 | 选择 | 理由 |
|------|------|------|
| DLL注入 + Hook | ✅ 选用 | 唯一能在全屏游戏上显示叠加层的方案 |
| 透明窗口叠加 | ❌ 不选 | 全屏游戏时会被盖住，看不到 |
| ETW系统追踪 | ❌ 不选 | 只能读数据，无法在游戏画面上显示 |

**通俗解释**：
> 想象游戏是一个密封的房间，你在房间外面贴告示牌（透明窗口），房间里的人看不到。
> 
> DLL注入就像派一个人**钻进房间里面**，在房间内部的墙上写字，房间里的人就能看到了。

---

### 4.2 注入方式：CreateRemoteThread

| 方案 | 选择 | 理由 |
|------|------|------|
| CreateRemoteThread | ✅ 选用 | Windows官方API，简单可靠 |
| Manual Mapping | ❌ 不选 | 更隐蔽但实现复杂，我们不需要躲避检测 |
| SetWindowsHookEx | ❌ 不选 | 只能Hook有窗口消息的程序，局限性大 |

**通俗解释**：
> 把DLL送进游戏进程，就像把包裹送进别人家。
> 
> - **CreateRemoteThread**：走正门送快递，简单直接
> - **Manual Mapping**：翻墙偷偷放进去，复杂但不容易被发现
> 
> 我们不是做外挂，不需要躲避检测，走正门就行。

---

### 4.3 Hook库：MinHook

| 方案 | 选择 | 理由 |
|------|------|------|
| MinHook | ✅ 选用 | 轻量、稳定、开源免费、使用简单 |
| Microsoft Detours | ❌ 不选 | 微软出品但授权复杂，商用需付费 |
| 手写Hook | ❌ 不选 | 需要深入汇编知识，容易出错 |

**通俗解释**：
> Hook就像在别人打电话时**插入一个分机**，你能听到通话内容，还能插嘴。
> 
> MinHook就是一个现成的"分机设备"，买来插上就能用，不用自己造。

---

### 4.4 Hook目标：IDXGISwapChain::Present

| 目标 | 选择 | 理由 |
|------|------|------|
| Present | ✅ 选用 | 每渲染完一帧必调用，是最佳计时点 |
| BeginScene/EndScene | ❌ 不选 | 只有DX9有，现代游戏用DX11/12 |
| Draw相关函数 | ❌ 不选 | 一帧内会调用成百上千次，不适合计数 |

**通俗解释**：
> 游戏渲染一帧画面就像画一幅画：
> - 画的过程中会画很多笔（Draw函数）—— 一帧几百上千次，没法用来计数
> - **画完后展示给观众看（Present函数）—— 一帧只调用一次，正好用来计时**
> 
> 我们在"展示"这一步插入计时器，就能精确知道每帧花了多久。

---

### 4.5 渲染库：ImGui

| 方案 | 选择 | 理由 |
|------|------|------|
| ImGui | ✅ 选用 | 游戏圈标配UI库，轻量高效，支持DX11 |
| 直接用D3D画 | ❌ 不选 | 画个文字都要写几百行代码 |
| Qt/其他GUI库 | ❌ 不选 | 太重了，不适合嵌入游戏 |

**通俗解释**：
> 要在游戏画面上显示"FPS: 60"这几个字：
> - **直接用DirectX画**：像用沙子一粒粒摆出字来，极其繁琐
> - **用ImGui**：像用打印机，告诉它"打印FPS: 60"就行
> 
> ImGui是游戏行业通用的"打印机"，几乎所有游戏内置工具、外挂、调试器都用它。

---

### 4.6 FPS计算：滑动窗口平均

| 方案 | 选择 | 理由 |
|------|------|------|
| 滑动窗口平均 | ✅ 选用 | 数值平滑，不会剧烈跳动 |
| 瞬时帧率 | ❌ 不选 | 每帧都不一样，数字会疯狂跳动 |
| 每秒统计一次 | ❌ 不选 | 更新太慢，不够实时 |

**通俗解释**：
> 测量心跳：
> - **瞬时测量**：这一秒跳1下=60次/分，下一秒跳2下=120次/分 —— 数字乱跳
> - **统计一分钟**：要等1分钟才出结果 —— 太慢
> - **取最近10秒平均**：既平滑又实时 —— 这就是滑动窗口
> 
> 我们取最近60帧的平均值，既稳定又反映实时情况。

---

### 4.7 选型总结（阶段1）

| 环节 | 选择 | 一句话理由 |
|------|------|-----------|
| 整体方案 | DLL注入+Hook | 唯一能在全屏游戏内显示的方法 |
| 注入方式 | CreateRemoteThread | 简单可靠的正规方法 |
| Hook库 | MinHook | 现成工具，不用自己造轮子 |
| Hook目标 | Present函数 | 一帧调用一次，正好用来计时 |
| 渲染库 | ImGui | 游戏圈标配，画UI最方便 |
| FPS算法 | 滑动窗口平均 | 数字稳定不乱跳 |

---

## 4.8 分阶段技术路线

### 4.8.1 为什么需要分阶段？

行业标杆产品的技术方案：

| 产品 | 技术方案 | 特点 |
|------|---------|------|
| GeForce Experience | 驱动层 Hook | NVIDIA 官方，最稳定 |
| RivaTuner (RTSS) | 驱动层 Hook | 业界公认最强，兼容性最好 |
| AMD Adrenalin | 驱动层 Hook | AMD 官方 |
| Steam Overlay | 类驱动层 | Valve 特殊权限 |

**结论**：专业级 FPS 显示工具都采用**驱动层方案**，这是最终目标。

但驱动开发门槛高，因此采用**分阶段递进**策略。

---

### 4.8.2 两种方案对比

```
┌────────────────────────────────────────────────────────────────┐
│                         渲染管线层级                            │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  应用层：  游戏 → DirectX Runtime  ← 阶段1在这里Hook            │
│              ↓                                                 │
│  驱动层：  NVIDIA/AMD 驱动         ← 阶段2在这里Hook            │
│              ↓                                                 │
│  硬件层：  GPU                                                  │
│              ↓                                                 │
│           显示器                                                │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

| 对比项 | 阶段1：用户态 | 阶段2：驱动层 |
|--------|-------------|--------------|
| Hook 位置 | DirectX Runtime | 内核驱动 |
| 实现难度 | ⭐⭐⭐ 中等 | ⭐⭐⭐⭐⭐ 困难 |
| 兼容性 | ⭐⭐⭐ 良好 | ⭐⭐⭐⭐⭐ 最佳 |
| 稳定性 | ⭐⭐⭐ 良好 | ⭐⭐⭐⭐⭐ 最佳 |
| 反作弊友好 | ❌ 容易被检测 | ✅ 难被检测 |
| API覆盖 | DX11 为主 | 全API覆盖 |
| 对游戏影响 | 注入进程，有风险 | 不注入，零风险 |

---

### 4.8.3 阶段1：用户态方案（快速原型）

**目标**：快速出成果，验证可行性，积累经验

**技术栈**：
```
注入方式：CreateRemoteThread + LoadLibrary
Hook层级：用户态 DXGI
Hook库：MinHook
渲染：ImGui
覆盖API：DirectX 11
```

**产出**：
- 可工作的 FPS 叠加层
- 支持大部分 DX11 游戏
- 完整的代码框架

**时间**：约 1 周

**局限**：
- 可能被反作弊检测
- 需要手动注入
- 部分游戏可能不兼容

---

### 4.8.4 阶段2：驱动层方案（专业级）

**目标**：达到 RTSS 级别的稳定性和兼容性

**技术栈**：
```
驱动类型：KMDF (Kernel-Mode Driver Framework)
Hook层级：内核态 dxgkrnl.sys
Hook方式：自研内核 Hook
渲染：驱动层直接渲染
覆盖API：DX9/10/11/12/OpenGL/Vulkan 全覆盖
```

**产出**：
- 专业级 FPS 叠加工具
- 全游戏兼容
- 反作弊友好

**时间**：约 3-4 周

**前置条件**：
- EV 代码签名证书（约 $300/年）
- 驱动开发经验
- 充分的测试环境

---

### 4.8.5 阶段3：产品化

**目标**：打磨成可发布的产品

**内容**：
```
├── 驱动签名与认证
├── 安装程序开发
├── 配置界面（独立GUI程序）
├── 自动更新机制
├── 多语言支持
└── 用户文档
```

**时间**：约 1-2 周

---

### 4.8.6 技术路线图

```
┌─────────────────────────────────────────────────────────────────────┐
│                          技术路线图                                  │
└─────────────────────────────────────────────────────────────────────┘

Week 1          Week 2-3        Week 4-5        Week 6-7
  │               │               │               │
  ▼               ▼               ▼               ▼
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│ 阶段1   │    │ 阶段2   │    │ 阶段2   │    │ 阶段3   │
│         │    │         │    │         │    │         │
│ 用户态  │───>│ 驱动    │───>│ 驱动    │───>│ 产品化  │
│ 原型    │    │ 开发    │    │ 完善    │    │         │
│         │    │         │    │         │    │         │
│ • DLL   │    │ • KMDF  │    │ • 全API │    │ • 签名  │
│ • Hook  │    │ • 内核  │    │ • 测试  │    │ • 安装  │
│ • ImGui │    │   Hook  │    │ • 优化  │    │ • GUI   │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
     │
     │ 验证可行性
     │ 积累经验
     ▼
  为阶段2打基础
```

---

### 4.8.7 阶段1为阶段2打基础

| 阶段1积累的经验 | 在阶段2的应用 |
|----------------|--------------|
| DirectX 渲染管线理解 | 内核层 Hook 点选择 |
| Present 函数工作原理 | dxgkrnl 对应函数定位 |
| FPS 计算算法 | 直接复用 |
| ImGui 渲染逻辑 | 改造为驱动层渲染 |
| 叠加层 UI 设计 | 直接复用 |

---

### 4.8.8 驱动层方案详细设计（阶段2预览）

**架构图**：
```
┌────────────────────────────────────────────────────────────────┐
│                         阶段2架构                               │
└────────────────────────────────────────────────────────────────┘

  用户态                              内核态
┌──────────────┐                   ┌──────────────────────────┐
│              │                   │                          │
│  配置程序    │◄── DeviceIoCtl ──►│   FPS Overlay Driver     │
│  (GUI)       │                   │   (.sys)                 │
│              │                   │                          │
│  • 设置位置  │                   │  ┌────────────────────┐  │
│  • 设置颜色  │                   │  │ Hook dxgkrnl.sys   │  │
│  • 开关叠加  │                   │  │                    │  │
│              │                   │  │ • DxgkPresent      │  │
└──────────────┘                   │  │ • 计算FPS          │  │
                                   │  │ • 渲染叠加层       │  │
                                   │  └─────────┬──────────┘  │
                                   │            │             │
                                   │            ▼             │
                                   │  ┌────────────────────┐  │
                                   │  │ GPU 渲染管线       │  │
                                   │  └────────────────────┘  │
                                   │                          │
                                   └──────────────────────────┘
```

**核心技术点**：

| 技术点 | 说明 |
|--------|------|
| KMDF 驱动开发 | Windows 内核驱动框架 |
| 内核 Hook | 拦截 dxgkrnl.sys 函数 |
| 内核态渲染 | 在驱动层直接操作显存 |
| 用户态通信 | DeviceIoCtl 传递配置 |
| 驱动签名 | EV 证书签名，通过 Windows 验证 |

---

### 4.8.9 风险与缓解

| 阶段 | 风险 | 缓解措施 |
|------|------|----------|
| 阶段1 | 被反作弊检测 | 仅用于单机/非竞技游戏 |
| 阶段1 | 部分游戏崩溃 | 完善异常处理，提供快速卸载 |
| 阶段2 | 驱动导致蓝屏 | 虚拟机测试，渐进式开发 |
| 阶段2 | 签名证书成本 | 确认商业价值后再购买 |
| 阶段2 | 开发周期长 | 阶段1验证可行性后再投入 |

---

### 4.8.10 决策点

```
阶段1完成后，评估：

┌─────────────────────────────────────────┐
│ 阶段1成果是否满足需求？                   │
└────────────────┬────────────────────────┘
                 │
        ┌────────┴────────┐
        ▼                 ▼
   ┌─────────┐       ┌─────────┐
   │ 满足    │       │ 不满足  │
   │         │       │         │
   │ 可选择: │       │ 继续:   │
   │ • 停留  │       │ • 阶段2 │
   │ • 继续  │       │         │
   └─────────┘       └─────────┘
```

**继续阶段2的条件**：
- 阶段1验证技术可行
- 需要更好的兼容性/稳定性
- 需要支持更多游戏/API
- 需要反作弊友好

---

## 5. 技术架构

### 5.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                        用户层                                │
│  ┌─────────────┐    ┌─────────────────────────────────────┐ │
│  │  Injector   │───>│          Game Process               │ │
│  │  注入器      │    │  ┌─────────────────────────────┐   │ │
│  └─────────────┘    │  │      FPS Overlay DLL        │   │ │
│                     │  │  ┌───────┐ ┌───────┐ ┌─────┐│   │ │
│                     │  │  │ Hook  │ │ FPS   │ │ImGui││   │ │
│                     │  │  │Manager│ │Counter│ │Render│   │ │
│                     │  │  └───┬───┘ └───────┘ └──┬──┘│   │ │
│                     │  └──────┼─────────────────┼────┘   │ │
│                     │         │                 │        │ │
│                     │  ┌──────▼─────────────────▼────┐   │ │
│                     │  │      DirectX 11 Runtime     │   │ │
│                     │  └─────────────────────────────┘   │ │
│                     └─────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 工作流程图

```
┌──────────────────────────────────────────────────────────────────┐
│                         完整工作流程                              │
└──────────────────────────────────────────────────────────────────┘

用户启动 Injector
        │
        ▼
┌───────────────────┐
│ 1. 查找游戏进程    │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ 2. 注入 DLL       │  ← 使用 CreateRemoteThread
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ 3. DLL 初始化     │
│  - 创建临时窗口    │
│  - 获取Present地址 │
└─────────┬─────────┘
          │
          ▼
┌───────────────────┐
│ 4. 安装 Hook      │  ← 使用 MinHook
└─────────┬─────────┘
          │
          ▼
┌───────────────────────────────────────────┐
│ 5. 游戏运行中（循环）                       │
│                                           │
│   游戏调用 Present()                       │
│         │                                 │
│         ▼                                 │
│   ┌─────────────┐                         │
│   │ 我们的Hook  │                         │
│   │ 函数被触发  │                         │
│   └──────┬──────┘                         │
│          │                                │
│          ├──→ 记录时间戳，计算FPS          │
│          │                                │
│          ├──→ 用ImGui渲染叠加层            │
│          │                                │
│          └──→ 调用原始Present，画面显示    │
│                                           │
└───────────────────────────────────────────┘
```

### 5.3 模块划分

```
fps-overlay/
├── injector/           # 注入器模块
│   └── main.cpp
├── overlay_dll/        # 核心DLL模块
│   ├── dllmain.cpp     # DLL入口
│   ├── hooks/          # Hook子模块
│   │   ├── hook_manager.cpp/.h
│   │   └── dx11_hook.cpp/.h
│   ├── core/           # 核心功能
│   │   ├── fps_counter.cpp/.h
│   │   └── config.cpp/.h
│   └── render/         # 渲染子模块
│       ├── overlay.cpp/.h
│       └── imgui/      # ImGui源码
└── common/             # 公共模块
    └── logger.cpp/.h
```

---

## 6. 模块详细设计

### 6.1 注入器模块 (Injector)

**职责**：将 overlay DLL 注入到目标游戏进程

**输入**：
- 目标进程名 或 进程ID (PID)

**输出**：
- 注入成功/失败状态

**技术方案**：
- 使用 `CreateRemoteThread` + `LoadLibrary` 方式注入
- 备选：Manual Mapping（更隐蔽，但实现复杂）

**接口定义**：
```cpp
namespace Injector {
    // 通过进程名注入
    bool InjectByName(const char* processName, const char* dllPath);
    
    // 通过PID注入
    bool InjectByPid(DWORD pid, const char* dllPath);
    
    // 获取最后的错误信息
    const char* GetLastErrorMessage();
}
```

---

### 6.2 Hook 管理模块 (Hook Manager)

**职责**：管理所有函数 Hook 的生命周期

**依赖**：MinHook 库

**Hook 目标**：

| 函数 | 来源 | VTable索引 | 用途 |
|------|------|------------|------|
| `IDXGISwapChain::Present` | dxgi.dll | 8 | 每帧渲染完成时触发 |
| `IDXGISwapChain::ResizeBuffers` | dxgi.dll | 13 | 窗口大小改变时触发 |

**接口定义**：
```cpp
namespace HookManager {
    bool Initialize();
    void Shutdown();
    
    bool CreateHook(void* target, void* detour, void** original);
    bool EnableAllHooks();
    bool DisableAllHooks();
}
```

---

### 6.3 DirectX 11 Hook 模块

**职责**：Hook DirectX 11 函数，拦截渲染流程

**工作流程**：
```
1. 创建临时窗口和 Dummy SwapChain
2. 从 SwapChain 虚函数表获取 Present 函数地址
3. 使用 MinHook 创建 Hook
4. 在 Hook 函数中：
   a. 首次调用时初始化渲染资源
   b. 更新 FPS 计数
   c. 渲染叠加层
   d. 调用原始 Present 函数
```

**接口定义**：
```cpp
namespace DX11Hook {
    bool Initialize();
    void Shutdown();
    
    // Hook回调（内部使用）
    HRESULT __stdcall PresentHook(IDXGISwapChain* swapChain, UINT syncInterval, UINT flags);
    HRESULT __stdcall ResizeBuffersHook(IDXGISwapChain* swapChain, UINT bufferCount, 
                                         UINT width, UINT height, DXGI_FORMAT format, UINT flags);
}
```

---

### 6.4 FPS 计算模块

**职责**：统计和计算帧率

**算法**：
- 采用滑动窗口平均法，取最近 N 帧（默认60帧）的平均值
- 避免数值跳动过于剧烈

**数据结构**：
```cpp
struct FrameStats {
    float fps;              // 当前FPS
    float frameTimeMs;      // 当前帧时间（毫秒）
    float avgFps;           // 平均FPS
    float minFps;           // 最小FPS（最近N帧）
    float maxFps;           // 最大FPS（最近N帧）
    float fps1PercentLow;   // 1% Low FPS
};
```

**接口定义**：
```cpp
namespace FpsCounter {
    void Update();                    // 每帧调用
    FrameStats GetStats();            // 获取统计数据
    void Reset();                     // 重置统计
    void SetSampleCount(size_t n);    // 设置采样数量
}
```

---

### 6.5 渲染叠加模块 (Overlay)

**职责**：在游戏画面上渲染 FPS 信息

**依赖**：ImGui 库

**渲染内容**：
```
┌─────────────────┐
│ FPS: 144.0      │  ← 根据数值变色
│ Frame: 6.94 ms  │
└─────────────────┘
```

**接口定义**：
```cpp
namespace Overlay {
    bool Initialize(HWND hwnd, ID3D11Device* device, ID3D11DeviceContext* context);
    void Render();
    void Shutdown();
    
    void SetVisible(bool visible);
    void SetPosition(float x, float y);
    void SetAlpha(float alpha);
}
```

---

### 6.6 配置模块

**职责**：管理用户配置

**配置项**：
```cpp
struct Config {
    // 显示设置
    bool showFps = true;
    bool showFrameTime = true;
    int positionPreset = 0;     // 0:左上 1:右上 2:左下 3:右下 4:自定义
    float customX = 10.0f;
    float customY = 10.0f;
    float alpha = 0.8f;
    float fontSize = 16.0f;
    
    // 颜色阈值
    float greenThreshold = 60.0f;
    float yellowThreshold = 30.0f;
    
    // 热键
    int toggleKey = VK_F1;
    
    // 采样设置
    int sampleCount = 60;
};
```

**存储格式**：INI 或 JSON 文件

---

## 7. 依赖项清单

| 依赖 | 版本 | 用途 | 许可证 | 获取方式 |
|------|------|------|--------|----------|
| MinHook | 1.3.3+ | 函数Hook | BSD-2 | https://github.com/TsudaKageWorker/minhook |
| ImGui | 1.89+ | UI渲染 | MIT | https://github.com/ocornut/imgui |
| DirectX 11 SDK | - | 图形API | - | Windows SDK 自带 |

**ImGui 需要的文件**：
- imgui.cpp/h
- imgui_draw.cpp
- imgui_tables.cpp
- imgui_widgets.cpp
- imgui_impl_win32.cpp/h
- imgui_impl_dx11.cpp/h

---

## 8. 开发计划

### 8.1 里程碑

| 阶段 | 内容 | 预估时间 | 交付物 |
|------|------|----------|--------|
| M1 | 项目搭建 + 基础DLL注入 | 1天 | 可注入的空DLL |
| M2 | DirectX 11 Hook | 1.5天 | 能拦截Present调用 |
| M3 | FPS计算 + 基础显示 | 1天 | 控制台输出FPS |
| M4 | ImGui集成 + 叠加渲染 | 1.5天 | 游戏内显示FPS |
| M5 | 完善功能 + 测试 | 1天 | 完整可用版本 |

**总计：约 6 天**

### 8.2 任务分解

#### M1: 项目搭建（1天）
- [ ] 创建 CMake 项目结构
- [ ] 集成 MinHook 库
- [ ] 集成 ImGui 库
- [ ] 实现基础 DLL 注入器
- [ ] 测试 DLL 注入功能

#### M2: DirectX 11 Hook（1.5天）
- [ ] 实现 Dummy SwapChain 创建
- [ ] 获取 Present 函数地址
- [ ] 实现 Present Hook
- [ ] 实现 ResizeBuffers Hook
- [ ] 处理设备丢失和重建

#### M3: FPS 计算（1天）
- [ ] 实现高精度计时
- [ ] 实现滑动窗口平均算法
- [ ] 计算帧时间统计
- [ ] 单元测试

#### M4: ImGui 渲染（1.5天）
- [ ] 初始化 ImGui 上下文
- [ ] 实现 Win32 后端
- [ ] 实现 DX11 后端
- [ ] 设计 FPS 显示界面
- [ ] 实现窗口消息 Hook（热键支持）

#### M5: 完善和测试（1天）
- [ ] 配置文件读写
- [ ] 多游戏兼容性测试
- [ ] 异常处理完善
- [ ] 内存泄漏检查
- [ ] 文档编写

---

## 9. 风险评估

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| 反作弊检测 | 高 | 高 | 仅用于单机/非竞技游戏；提供免责声明 |
| 游戏崩溃 | 中 | 高 | 完善异常处理；提供快速卸载机制 |
| 兼容性问题 | 中 | 中 | 优先支持主流游戏；收集用户反馈 |
| 全屏模式失效 | 低 | 中 | 正确处理 ResizeBuffers |
| 性能影响过大 | 低 | 中 | 优化渲染逻辑；减少不必要计算 |

---

## 10. 测试计划

### 10.1 单元测试
- FPS 计算模块准确性测试
- 配置读写测试

### 10.2 集成测试
- DLL 注入成功率测试
- Hook 安装/卸载测试

### 10.3 兼容性测试

| 游戏 | 图形API | 窗口模式 | 状态 |
|------|---------|----------|------|
| 英雄联盟 | DX11 | 无边框 | 待测 |
| CS2 | DX11 | 全屏 | 待测 |
| 原神 | DX11 | 无边框 | 待测 |
| 艾尔登法环 | DX12 | 全屏 | 待测（需DX12支持） |

---

## 11. 附录

### 11.1 术语表

| 术语 | 解释 |
|------|------|
| FPS | Frames Per Second，每秒帧数 |
| Hook | 拦截函数调用，插入自定义逻辑 |
| DLL注入 | 将动态链接库加载到其他进程 |
| SwapChain | DirectX 交换链，管理前后缓冲区 |
| Present | 将渲染结果呈现到屏幕的操作 |
| VTable | 虚函数表，C++ 多态实现机制 |
| 滑动窗口 | 保留最近N个样本计算平均值的算法 |

### 11.2 参考资料

- [MinHook GitHub](https://github.com/TsudaKageWorker/minhook)
- [ImGui GitHub](https://github.com/ocornut/imgui)
- [DirectX 11 Documentation](https://docs.microsoft.com/en-us/windows/win32/direct3d11)
- [Kiero - Universal Graphical Hook](https://github.com/Rebzzel/kiero)

---

### 11.3 Launcher 启动器需求演进记录

#### 版本 1：基础注入器 (injector.exe)

**需求：** 命令行方式注入 DLL 到运行中的进程

**使用方式：**
```
injector.exe Game.exe
injector.exe 12345
```

**问题：** 权限问题导致 CreateRemoteThread 失败（Error 5）

---

#### 版本 2：启动器模式 (launcher.exe)

**需求：** 解决注入权限问题，支持多种启动方式

**实现方案：**
- CREATE_SUSPENDED 创建进程 → 注入 → ResumeThread
- 支持拖拽 .exe / .lnk / .url 文件
- 支持文件选择对话框
- 自动解析 Steam 快捷方式

**问题：** Steam 游戏无法直接启动（需要 Steam 验证）

---

#### 版本 3：同目录启动模式

**需求：** 更简单的使用方式，减少操作步骤

**实现方案：**
1. 将 `launcher.exe` + `fps_overlay.dll` 复制到游戏目录
2. 双击 `launcher.exe`
3. 自动检测同目录下的游戏 exe
4. 自动启动并注入

**使用方式：**
```
GameFolder/
├── Game.exe           ← 游戏
├── launcher.exe       ← 复制
└── fps_overlay.dll    ← 复制

双击 launcher.exe 即可
```

---

#### 版本 4：后台自动监控模式（当前版本）

**需求：** 一次配置，多游戏自动注入，无需每次手动操作

**实现方案：**
1. 配置文件 `games.txt` 记录游戏进程名
2. `launcher.exe` 后台持续运行
3. 定期扫描进程列表
4. 检测到配置的游戏启动时，自动注入
5. 记录已注入 PID，避免重复注入

**配置文件格式 (games.txt)：**
```
# FPS Overlay - Game List
# 每行一个游戏进程名
Brawlhalla.exe
HollowKnight.exe
Cuphead.exe
```

**使用方式：**
```
1. 编辑 games.txt 添加游戏
2. 运行 launcher.exe（后台监控）
3. 正常启动任何游戏
4. 自动注入，显示 FPS
```

**运行流程：**
```
launcher.exe 启动
     ↓
读取 games.txt
     ↓
后台循环监控 ←────────────┐
     ↓                    │
检测进程列表               │
     ↓                    │
发现新游戏进程？ ──否──→ 等待1秒 ─┘
     ↓ 是
等待2秒初始化
     ↓
注入 fps_overlay.dll
     ↓
记录 PID，继续监控
```

---

#### 版本 5：托盘后台模式（当前版本）

**需求：** V4 关闭控制台窗口后程序终止，需要真正的后台运行

**实现方案：**
1. Windows GUI 程序（非控制台）
2. 系统托盘图标
3. 后台监控线程
4. 托盘通知提示
5. 右键菜单（编辑配置/退出）
6. 单实例检测

**技术要点：**
- `WinMain` 入口（WIN32 子系统）
- `Shell_NotifyIconW` 创建托盘图标
- `CreateThread` 后台监控
- 隐藏窗口消息循环

**使用方式：**
```
1. 运行 launcher.exe → 最小化到托盘
2. 正常启动游戏
3. 自动注入 → 托盘通知
4. 右键托盘图标可退出
```

**运行效果：**
```
                              ┌─────────────────────────────┐
                              │ FPS Overlay Started         │
系统托盘图标 ──────────────→  │ Monitoring 3 game(s)        │
                              └─────────────────────────────┘

启动游戏后 ──────────────────→ ┌─────────────────────────────┐
                              │ FPS Overlay                 │
                              │ Brawlhalla.exe - Injected!  │
                              │ Press F1 to toggle.         │
                              └─────────────────────────────┘
```

---

#### 启动方式对比总结

| 版本 | 使用方式 | 适用场景 | 便捷度 |
|------|----------|----------|--------|
| V1 注入器 | 命令行 | 开发调试 | ⭐ |
| V2 启动器 | 拖拽/选择 | 单次使用 | ⭐⭐ |
| V3 同目录 | 双击 | 固定游戏 | ⭐⭐⭐ |
| V4 控制台监控 | 保持窗口打开 | 临时测试 | ⭐⭐⭐⭐ |
| V5 托盘后台 | 一劳永逸 | 日常使用 | ⭐⭐⭐⭐⭐ |
