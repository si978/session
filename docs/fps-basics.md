# FPS 基础知识文档

## 1. 什么是 FPS？

**FPS = Frames Per Second（每秒帧数）**

就像电影是由一张张静止的图片快速播放形成的动画，游戏画面也是一帧一帧渲染出来的。

| FPS 数值 | 体验 |
|----------|------|
| < 30 | 明显卡顿，难以游玩 |
| 30-60 | 基本流畅，可接受 |
| 60+ | 流畅，主流标准 |
| 144+ | 非常流畅，电竞级别 |

---

## 2. FPS 是谁计算和显示的？

### 2.1 答案：游戏自身

**不是显卡，是游戏程序自己计算并显示的。**

### 2.2 为什么不是显卡？

显卡是一个**没有时间观念的执行者**：

```
游戏：画这个三角形
显卡：好的（画完了）

游戏：画这个人物  
显卡：好的（画完了）

游戏：画面完成，显示出来！
显卡：好的（执行 Present）

游戏：开始画下一帧...
显卡：好的...
```

显卡只是**被动执行命令**，它不关心：
- 这是第几帧
- 距离上一帧过了多久
- 一秒钟画了几帧

**游戏（程序）才是发号施令的人，所以只有游戏知道自己一秒钟下了几次命令。**

---

## 3. 类比理解

### 3.1 餐厅厨房类比

| 角色 | 对应 | 职责 |
|------|------|------|
| 厨师 | **CPU + 游戏逻辑** | 决定做什么菜、怎么摆盘 |
| 烤箱/炉灶 | **显卡 (GPU)** | 按照厨师指令加热、烹饪 |
| 上菜动作 | **Present 函数** | 把做好的菜端给顾客 |
| 顾客 | **显示器** | 接收并"看到"画面 |

```
FPS = 每秒钟上了多少次菜
```

- 烤箱（显卡）只管烤，不知道一秒烤了几次
- 厨师（游戏）才知道自己一秒下了几次"上菜"命令

### 3.2 流水线工人类比

```
┌─────────────────────────────────────────────────────┐
│                    游戏（老板）                      │
│                                                     │
│  "我要统计每秒生产多少个产品"                        │
│  "我知道每次下单的时间"                              │
│  "所以我能算出生产效率（FPS）"                       │
│                                                     │
└────────────────────────┬────────────────────────────┘
                         │ 下达生产指令
                         ▼
┌─────────────────────────────────────────────────────┐
│                    显卡（工人）                      │
│                                                     │
│  "老板让我画啥我就画啥"                              │
│  "我不看表，不数数"                                  │
│  "我只管埋头干活"                                    │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

## 4. 游戏如何计算 FPS

### 4.1 游戏主循环

每个游戏内部都有一个不断重复的"主循环"：

```
游戏启动

无限循环 {
    1. 处理玩家输入（键盘、鼠标）
    2. 更新游戏逻辑（人物移动、物理碰撞、AI）
    3. 渲染画面（命令显卡绘制所有物体）
    4. 显示画面（调用 Present，把画面推到屏幕）
    
    ↑ 这就是"一帧"
}
```

### 4.2 FPS 计算方法

```
每一帧 {
    记录开始时间
    
    ... 处理游戏逻辑 ...
    ... 渲染画面 ...
    调用 Present()
    
    记录结束时间
    
    这一帧耗时 = 结束时间 - 开始时间
    FPS = 1000毫秒 / 这一帧耗时(毫秒)
}
```

**举例**：
- 一帧耗时 16.67 毫秒 → FPS = 1000 / 16.67 = **60 FPS**
- 一帧耗时 6.94 毫秒 → FPS = 1000 / 6.94 = **144 FPS**
- 一帧耗时 33.33 毫秒 → FPS = 1000 / 33.33 = **30 FPS**

### 4.3 游戏如何显示 FPS

游戏计算出 FPS 后，把这个数字**当作画面的一部分画上去**：

```
每一帧 {
    ... 画游戏场景 ...
    ... 画人物 ...
    ... 画UI ...
    
    画一个文字 "FPS: 60" 在右上角  ← 就是普通的文字绘制
    
    Present() 显示出来
}
```

**所以游戏右上角的 FPS 数字，本质上和游戏里的血条、地图一样，都是游戏自己画的。**

---

## 5. 帧时间 vs FPS

### 5.1 两者的关系

| 指标 | 含义 | 公式 |
|------|------|------|
| 帧时间 (Frame Time) | 渲染一帧花了多久 | 直接测量 |
| FPS | 每秒能渲染多少帧 | 1000ms / 帧时间 |

```
帧时间 = 16.67ms  →  FPS = 60
帧时间 = 8.33ms   →  FPS = 120
帧时间 = 33.33ms  →  FPS = 30
```

### 5.2 为什么专业人士更关注帧时间？

FPS 会掩盖卡顿问题：

```
情况A：稳定 60 FPS
每帧耗时：16ms, 16ms, 16ms, 16ms, 16ms, 16ms
体验：非常流畅

情况B：平均也是 60 FPS
每帧耗时：8ms, 8ms, 8ms, 50ms, 8ms, 8ms
体验：有明显卡顿（那一帧 50ms 会感觉到顿一下）
```

**帧时间波动比平均 FPS 更能反映真实体验。**

---

## 6. 第三方工具如何获取 FPS

既然 FPS 是游戏自己算的，第三方工具（如 Fraps、我们的工具）怎么知道？

### 6.1 核心原理：Hook（钩子）

```
正常流程：
游戏 ──── Present() ────> 显卡 ────> 显示器

插入 Hook 后：
游戏 ─── Present() ───> 我们的代码 ─── Present() ───> 显卡 ───> 显示器
                              │
                              └──> 记录时间，计算 FPS
```

### 6.2 通俗解释

想象游戏和显卡之间有一条电话线：

```
游戏每画完一帧，就打电话给显卡："画面好了，显示出来！"
```

我们的工具做的事情：

```
在电话线中间接了一个分机

游戏打电话 → 我们先接到 → 记录一下时间 → 再转接给显卡
```

这样每次游戏"打电话"，我们都知道，于是我们也能统计每秒打了几次电话（FPS）。

### 6.3 技术术语对照

| 通俗说法 | 技术术语 |
|----------|----------|
| 电话线 | DirectX API |
| 打电话说"显示画面" | 调用 Present 函数 |
| 接分机 | Hook Present 函数 |
| 记录时间 | 高精度计时器 |
| 统计每秒几次 | 计算 FPS |

### 6.4 为什么不需要针对每个游戏做适配？

既然 FPS 是游戏自己算的，我们是不是需要针对每个游戏做适配？

**答案：不需要。因为我们不是读取游戏的 FPS，而是自己算。**

#### 两种思路对比

| 思路 | 做法 | 是否需要适配 |
|------|------|--------------|
| ❌ 读取游戏的 FPS | 找游戏内存中 FPS 存储位置 | 需要，每个游戏存的位置不同 |
| ✅ 自己计算 FPS | Hook 通用的 Present 函数 | **不需要** |

#### 关键：Present 是标准接口

```
所有 DirectX 11 游戏都必须调用：

IDXGISwapChain::Present()

这是微软定的标准，不是游戏自己发明的。
```

**类比理解**：

> 不管是奔驰、宝马还是丰田，都必须去加油站加油。
> 
> 我们只需要在**加油站**门口蹲守，就能统计所有车的加油频率。
> 
> 不需要针对每个汽车品牌做适配。

#### 错误理解 vs 正确理解

**❌ 错误理解（需要匹配游戏）**

```
英雄联盟把 FPS 存在内存地址 0x12345678
CS2 把 FPS 存在内存地址 0xABCDEF00
原神把 FPS 存在内存地址 0x99887766

→ 每个游戏都要逆向分析，找到存储位置
→ 游戏更新后地址可能变化，又要重新找
→ 工作量巨大，不现实
```

**✅ 正确理解（不需要匹配）**

```
所有 DirectX 11 游戏都调用同一个函数：
IDXGISwapChain::Present()

我们只需要 Hook 这一个函数：
→ 英雄联盟调用 Present，我们记录时间
→ CS2 调用 Present，我们记录时间  
→ 原神调用 Present，我们记录时间

→ 一套代码通吃所有 DX11 游戏
```

#### 图示说明

```
┌─────────────────────────────────────────────────────────────┐
│                    DirectX 11 标准接口                       │
│                                                             │
│    英雄联盟 ──┐                                              │
│              │                                              │
│    CS2 ──────┼──────> IDXGISwapChain::Present() ──> 显示器  │
│              │                    ↑                         │
│    原神 ─────┘                    │                         │
│                                   │                         │
│                          我们在这里 Hook                     │
│                          一个点搞定所有游戏                   │
└─────────────────────────────────────────────────────────────┘
```

#### 唯一需要适配的：图形 API 类型

不同游戏可能使用不同的图形 API：

| 图形 API | Hook 目标 | 覆盖游戏 |
|----------|----------|----------|
| DirectX 9 | `IDirect3DDevice9::Present` | 老游戏 |
| DirectX 11 | `IDXGISwapChain::Present` | 主流游戏（80%+） |
| DirectX 12 | `IDXGISwapChain::Present` | 新游戏 |
| OpenGL | `wglSwapBuffers` | 部分独立游戏 |
| Vulkan | `vkQueuePresentKHR` | 新引擎游戏 |

**策略**：先支持 DirectX 11，即可覆盖绝大多数主流游戏。

#### 总结

| 问题 | 答案 |
|------|------|
| 需要针对每个游戏做适配吗？ | **不需要** |
| 为什么？ | 我们 Hook 的是**标准 API**，不是游戏内部数据 |
| 需要适配什么？ | 只需适配**图形 API 类型**（DX9/11/12/OpenGL/Vulkan） |
| 一套代码能支持多少游戏？ | 支持 DX11 就能覆盖绝大多数主流游戏 |

### 6.5 Hook 怎么识别是哪个游戏？

**答案：不需要识别，因为我们已经"进入"了那个游戏。**

#### 流程回顾

```
┌─────────────┐                    ┌─────────────────────┐
│  Injector   │                    │     游戏进程         │
│  (注入器)    │                    │                     │
│             │                    │  ┌───────────────┐  │
│  用户指定：  │ ── 注入DLL ──────> │  │ 我们的DLL     │  │
│  "LOL.exe"  │                    │  │ (只在这里运行) │  │
│             │                    │  └───────────────┘  │
└─────────────┘                    └─────────────────────┘
```

#### 类比理解

> **Injector（注入器）** = 快递员
> 
> **DLL** = 包裹
> 
> **游戏进程** = 收件人家里

```
快递员根据地址（进程名）把包裹送到指定的家里

包裹进了家门之后，它只在这一家里工作
不需要再问"我在谁家？"——它就在 LOL 家里
```

#### 工作流程

```
1. 用户运行：injector.exe LOL.exe
                           ↑
                      用户指定目标游戏

2. Injector 找到 LOL.exe 进程，把 DLL 注入进去

3. DLL 在 LOL 进程内部运行：
   - Hook 这个进程的 Present 函数
   - 记录这个进程的帧时间
   - 在这个进程的画面上显示 FPS

4. DLL 不需要知道自己在哪个游戏里
   它只管 Hook → 计时 → 显示
```

### 6.6 怎么在游戏画面上展示 FPS？

#### 时机：在 Present 之前"加塞"

```
游戏正常流程：
游戏画完所有东西 → Present() → 显示到屏幕

我们插入后：
游戏画完所有东西 → 【我们画FPS】→ Present() → 显示到屏幕
                      ↑
                  在这里加塞一笔
```

#### 类比理解

> 游戏画画就像画一幅油画：
> 
> 1. 游戏画好了风景、人物、UI
> 2. 准备装裱挂墙上（Present）
> 
> 我们做的事：
> 
> 3. **在装裱之前，在画的角落签个名（画FPS数字）**
> 4. 然后再装裱挂墙上
> 
> 观众看到的画，就自带我们的签名了

#### 代码层面（简化）

```cpp
// 我们的 Hook 函数
HRESULT 我们的Present(IDXGISwapChain* swapChain, ...) {
    
    // ===== 游戏已经画完了，画面在显存里 =====
    
    // 第一步：计算 FPS
    float fps = 计算帧率();
    
    // 第二步：在画面上再画一层（用 ImGui）
    ImGui开始绘制();
    ImGui画文字("FPS: %.1f", fps);  // 在左上角画 "FPS: 60.0"
    ImGui结束绘制();
    
    // ===== 现在画面上多了我们的 FPS 文字 =====
    
    // 第三步：调用原始 Present，把画面显示出来
    return 原始Present(swapChain, ...);
}
```

#### 图示

```
┌─────────────────────────────────────────────────────────────┐
│                      游戏渲染一帧                            │
└─────────────────────────────────────────────────────────────┘

    游戏代码                        显存（画布）
   ┌────────┐                    ┌─────────────────┐
   │ 画天空  │ ────────────────> │ 天空            │
   │ 画地面  │ ────────────────> │ 天空 山         │
   │ 画人物  │ ────────────────> │ 天空 山 人      │
   │ 画UI   │ ────────────────> │ 天空 山 人 血条  │
   └────────┘                    └─────────────────┘
        │                                │
        │ 准备调用 Present               │
        ▼                                │
   ┌────────────────┐                    │
   │ 我们的 Hook    │                    ▼
   │                │             ┌─────────────────┐
   │ 画 FPS 文字    │ ──────────> │ 天空 山 人 血条  │
   │                │             │ FPS: 60 ← 我们加的
   └───────┬────────┘             └─────────────────┘
           │                             │
           │ 调用原始 Present            │
           ▼                             ▼
   ┌────────────────┐             ┌─────────────────┐
   │ 原始 Present   │ ──────────> │    显示器       │
   └────────────────┘             └─────────────────┘
```

#### 总结

| 问题 | 答案 |
|------|------|
| Hook 怎么识别游戏？ | **不需要识别**，Injector 已经把 DLL 送进指定游戏了 |
| 怎么在游戏上显示 FPS？ | 在 Present 之前，**用 ImGui 在画面上加画一层** |
| 为什么玩家能看到？ | 因为我们画完之后，才调用真正的 Present 显示出来 |

---

## 7. 渲染流程全景图

```
┌─────────────────────────────────────────────────────────────────┐
│                         一帧的完整流程                           │
└─────────────────────────────────────────────────────────────────┘

     CPU（游戏逻辑）                    GPU（图形渲染）
    ┌─────────────┐                  ┌─────────────┐
    │             │                  │             │
    │ 1.处理输入   │                  │             │
    │   ↓         │                  │             │
    │ 2.更新逻辑   │                  │             │
    │   ↓         │                  │             │
    │ 3.生成绘制   │ ──── 命令 ────>  │ 4.执行绘制   │
    │   命令      │                  │   命令      │
    │             │                  │   ↓         │
    │             │                  │ 5.画面完成   │
    │             │                  │             │
    │ 6.Present() │ ──── 信号 ────>  │ 7.输出到    │ ───> 显示器
    │  (我们在此   │                  │   显示器    │
    │   插入Hook)  │                  │             │
    │             │                  │             │
    └─────────────┘                  └─────────────┘
    
    ───────────────────────────────────────────────────────────────
                              这就是一帧
    ───────────────────────────────────────────────────────────────
    
    FPS = 1秒 / 一帧耗时
```

---

## 8. 常见问题

### Q1: 为什么有的游戏没有 FPS 显示选项？

游戏开发者没有做这个功能。FPS 显示是可选的，不是必须的。

### Q2: Steam 的 FPS 显示是怎么实现的？

和我们的原理一样，Steam 客户端通过 Hook 游戏的 Present 函数来计算和显示 FPS。

### Q3: 显卡驱动（如 NVIDIA GeForce Experience）的 FPS 显示呢？

同样原理。显卡驱动有更底层的权限，可以更方便地 Hook DirectX 函数。

### Q4: 为什么我的 FPS 数字一直在跳动？

因为每帧耗时都略有不同。解决方法是用"滑动窗口平均"，取最近 N 帧的平均值，这样数字就稳定了。

### Q5: FPS 高一定流畅吗？

不一定。如果帧时间波动很大（一会 10ms，一会 50ms），即使平均 FPS 很高，也会感觉卡顿。所以专业测试会看"1% Low FPS"和帧时间曲线。

---

## 9. 术语表

| 术语 | 英文 | 解释 |
|------|------|------|
| FPS | Frames Per Second | 每秒帧数 |
| 帧 | Frame | 一张静止的游戏画面 |
| 帧时间 | Frame Time | 渲染一帧所需的时间 |
| 渲染 | Render | 将游戏数据转化为可显示的图像 |
| Present | Present | 将渲染好的画面推送到屏幕显示 |
| Hook | Hook | 拦截函数调用，插入自定义代码 |
| GPU | Graphics Processing Unit | 图形处理器，即显卡 |
| CPU | Central Processing Unit | 中央处理器 |
| DirectX | DirectX | 微软的图形API，游戏用它与显卡通信 |
| 主循环 | Game Loop | 游戏不断重复执行的核心循环 |
| 滑动窗口 | Sliding Window | 取最近N个样本计算平均值的方法 |
| DLL | Dynamic Link Library | 动态链接库 |
| VTable | Virtual Table | 虚函数表，C++多态实现机制 |
| SwapChain | Swap Chain | 交换链，管理前后缓冲区 |
| Inline Hook | Inline Hook | 内联钩子，修改函数开头指令 |
| Trampoline | Trampoline | 跳板，保存被覆盖的原始指令 |
| ImGui | Immediate Mode GUI | 即时模式图形界面库 |

---

## 10. DirectX 11 渲染管线

### 10.1 什么是渲染管线？

**渲染管线 = 把游戏数据变成屏幕画面的流水线**

```
游戏数据（人物坐标、模型、贴图）
         │
         ▼
    ┌─────────┐
    │ 渲染管线 │  ← 一系列处理步骤
    └─────────┘
         │
         ▼
屏幕上的画面（像素点）
```

**类比理解**：

> 把渲染管线想象成一个**汽车组装流水线**：
> 
> ```
> 原材料 → 冲压 → 焊接 → 涂装 → 总装 → 成品汽车
> ```
> 
> 游戏渲染也是类似：
> 
> ```
> 3D模型 → 顶点处理 → 图元装配 → 光栅化 → 像素处理 → 画面
> ```

### 10.2 DirectX 11 渲染管线阶段

```
┌─────────────────────────────────────────────────────────────────┐
│                    DirectX 11 渲染管线                           │
└─────────────────────────────────────────────────────────────────┘

     CPU 端                              GPU 端
  ┌──────────┐                    ┌────────────────────────────┐
  │          │                    │                            │
  │ 游戏逻辑 │                    │  ┌────────────────────┐    │
  │          │                    │  │ 1. 输入装配 (IA)   │    │
  │ 准备数据 │ ───── 提交 ─────>  │  │    顶点/索引数据   │    │
  │ 发送命令 │                    │  └─────────┬──────────┘    │
  │          │                    │            ▼               │
  └──────────┘                    │  ┌────────────────────┐    │
                                  │  │ 2. 顶点着色器 (VS) │    │
                                  │  │    处理每个顶点    │    │
                                  │  └─────────┬──────────┘    │
                                  │            ▼               │
                                  │  ┌────────────────────┐    │
                                  │  │ 3. 光栅化 (RS)     │    │
                                  │  │    三角形→像素     │    │
                                  │  └─────────┬──────────┘    │
                                  │            ▼               │
                                  │  ┌────────────────────┐    │
                                  │  │ 4. 像素着色器 (PS) │    │
                                  │  │    计算像素颜色    │    │
                                  │  └─────────┬──────────┘    │
                                  │            ▼               │
                                  │  ┌────────────────────┐    │
                                  │  │ 5. 输出合并 (OM)   │    │
                                  │  │    混合/深度测试   │    │
                                  │  └─────────┬──────────┘    │
                                  │            ▼               │
                                  │     渲染目标 (画面)        │
                                  │                            │
                                  └────────────────────────────┘
```

### 10.3 各阶段通俗解释

| 阶段 | 名称 | 做什么 | 类比 |
|------|------|--------|------|
| 1 | 输入装配 (IA) | 读取顶点数据 | 取出零件 |
| 2 | 顶点着色器 (VS) | 处理每个顶点位置 | 确定零件摆放位置 |
| 3 | 光栅化 (RS) | 把三角形变成像素点 | 把设计图变成实物 |
| 4 | 像素着色器 (PS) | 计算每个像素的颜色 | 给零件上色 |
| 5 | 输出合并 (OM) | 混合、深度测试 | 组装成品 |

### 10.4 关键概念

#### Device（设备）

```
ID3D11Device = 显卡的代表

职责：创建资源（纹理、缓冲区、着色器等）

类比：工厂的采购部门，负责准备原材料
```

#### DeviceContext（设备上下文）

```
ID3D11DeviceContext = 渲染命令的执行者

职责：设置渲染状态、发送绘制命令

类比：工厂的生产线控制中心，负责指挥生产
```

#### SwapChain（交换链）

```
IDXGISwapChain = 前后缓冲区的管理者

职责：管理画面的双缓冲，调用 Present 显示画面

类比：成品仓库和展示厅之间的传送带
```

### 10.5 双缓冲机制

```
┌─────────────────────────────────────────────────────────────────┐
│                        双缓冲原理                                │
└─────────────────────────────────────────────────────────────────┘

┌──────────────┐                    ┌──────────────┐
│   后缓冲区   │                    │   前缓冲区   │
│ (Back Buffer)│                    │(Front Buffer)│
│              │                    │              │
│  GPU正在画   │ ─── Present() ──>  │  正在显示    │ ──> 显示器
│  下一帧      │      交换          │  当前帧      │
│              │                    │              │
└──────────────┘                    └──────────────┘

为什么需要双缓冲？
- 如果只有一个缓冲区，GPU边画边显示，画面会撕裂
- 双缓冲：GPU在后台画完，一次性切换，画面完整

Present() 做的事：
- 把后缓冲区的画面切换到前缓冲区
- 这就是我们 Hook 的目标！
```

### 10.6 我们 Hook 的位置

```
游戏代码
    │
    │  创建
    ▼
┌──────────────────┐
│   ID3D11Device   │  ← 设备
└────────┬─────────┘
         │ 创建
         ▼
┌──────────────────┐
│  IDXGISwapChain  │  ← 交换链
└────────┬─────────┘
         │
         │  包含多个函数（虚函数表）
         │
         │  [0] QueryInterface
         │  [1] AddRef
         │  [2] Release
         │  ...
         │  [8] Present        ← 我们 Hook 这个！
         │  ...
         │  [13] ResizeBuffers ← 窗口大小变化时也要 Hook
         │
         ▼
      渲染完成
```

### 10.7 为什么 Hook Present？

| 原因 | 说明 |
|------|------|
| **时机完美** | 游戏画完所有东西，准备显示，这时候我们加一层 |
| **一帧一次** | 每帧只调用一次，正好用来计时 |
| **标准接口** | 所有 DX11 游戏都调用这个函数 |
| **可以渲染** | 此时可以拿到设备上下文，可以画东西 |

---

## 11. DLL 注入原理

### 11.1 什么是 DLL？

**DLL = Dynamic Link Library（动态链接库）**

```
普通程序 (.exe)：独立运行的程序
动态库 (.dll)：不能独立运行，被其他程序加载后才能执行
```

**类比**：
> - EXE 像一辆完整的汽车，可以自己跑
> - DLL 像一个发动机，需要装到车里才能工作

### 11.2 什么是 DLL 注入？

**DLL 注入 = 强行把我们的 DLL 加载到别人的进程里**

```
正常情况：
┌─────────────┐     ┌─────────────┐
│ 游戏.exe    │     │ 我们的.dll  │
│             │     │             │
│ 游戏自己的  │     │ 孤零零的    │
│ DLL们      │     │ 没人加载    │
└─────────────┘     └─────────────┘
      ↑                    
   独立运行              无法运行


注入之后：
┌─────────────────────────────┐
│         游戏.exe            │
│                             │
│  ┌─────────┐ ┌───────────┐ │
│  │游戏自己 │ │ 我们的.dll │ │
│  │的DLL们  │ │  (注入的)  │ │
│  └─────────┘ └───────────┘ │
│                             │
│  共享同一个进程空间         │
└─────────────────────────────┘
```

### 11.3 为什么要注入？

| 目的 | 说明 |
|------|------|
| **共享地址空间** | 注入后，我们的代码和游戏代码在同一个进程里，可以直接访问游戏的内存 |
| **Hook 函数** | 只有在同一个进程里，才能修改游戏调用的函数 |
| **渲染叠加** | 只有在同一个进程里，才能使用游戏的 DirectX 设备来画东西 |

### 11.4 Windows 进程基础

```
每个进程都有独立的虚拟地址空间：

┌──────────────────────────────────────┐
│              进程 A                  │
│  ┌────────────────────────────────┐  │
│  │         虚拟地址空间            │  │
│  │  0x00000000 ─────────────────  │  │
│  │       │  代码区                │  │
│  │       │  数据区                │  │
│  │       │  堆                    │  │
│  │       │  栈                    │  │
│  │       │  加载的 DLL            │  │
│  │       ▼                        │  │
│  │  0xFFFFFFFF ─────────────────  │  │
│  └────────────────────────────────┘  │
│                                      │
│  进程 A 看不到进程 B 的内存          │
└──────────────────────────────────────┘

问题：我们的注入器是进程 A，游戏是进程 B
      如何让进程 B 加载我们的 DLL？
```

### 11.5 DLL 注入的核心思路

```
我们不能直接操作游戏进程的内存
但是 Windows 提供了一些"跨进程"的 API

核心思路：
1. 打开目标进程（获取操作权限）
2. 在目标进程里分配内存（放 DLL 路径）
3. 在目标进程里创建线程（执行 LoadLibrary）
4. 目标进程自己加载我们的 DLL
```

### 11.6 关键 API 讲解

#### 第一步：打开进程

```cpp
HANDLE hProcess = OpenProcess(
    PROCESS_ALL_ACCESS,  // 请求完全访问权限
    FALSE,
    游戏的PID            // 游戏进程ID
);

// 类比：拿到游戏进程的"钥匙"
```

#### 第二步：在目标进程分配内存

```cpp
LPVOID pRemoteMemory = VirtualAllocEx(
    hProcess,            // 目标进程
    NULL,                // 让系统选择地址
    路径长度,            // 分配大小
    MEM_COMMIT,          // 提交内存
    PAGE_READWRITE       // 可读写
);

// 类比：在游戏的"家"里借一块空地
```

#### 第三步：写入 DLL 路径

```cpp
WriteProcessMemory(
    hProcess,            // 目标进程
    pRemoteMemory,       // 刚分配的内存地址
    "C:\\我们的.dll",    // DLL 完整路径
    路径长度,
    NULL
);

// 类比：在借来的空地上放一张纸条，写着 DLL 的位置
```

#### 第四步：创建远程线程执行 LoadLibrary

```cpp
HANDLE hThread = CreateRemoteThread(
    hProcess,                          // 目标进程
    NULL,
    0,
    (LPTHREAD_START_ROUTINE)LoadLibraryA,  // 线程入口：LoadLibrary
    pRemoteMemory,                     // 参数：DLL 路径
    0,
    NULL
);

// 类比：雇一个人去游戏家里，让他按纸条上的地址取快递（加载DLL）
```

### 11.7 完整流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                      DLL 注入流程                                │
└─────────────────────────────────────────────────────────────────┘

  注入器 (我们的程序)                    游戏进程
  ┌──────────────────┐                ┌──────────────────┐
  │                  │                │                  │
  │ 1. OpenProcess   │ ────────────>  │  (获得操作权限)  │
  │                  │                │                  │
  │ 2. VirtualAllocEx│ ────────────>  │  [分配一块内存]  │
  │                  │                │        ↓         │
  │ 3. WriteProcess  │ ────────────>  │  [写入DLL路径]   │
  │    Memory        │                │  "C:\fps.dll"   │
  │                  │                │        ↓         │
  │ 4. CreateRemote  │ ────────────>  │  [创建新线程]    │
  │    Thread        │                │        ↓         │
  │                  │                │  线程执行:       │
  │                  │                │  LoadLibrary(    │
  │                  │                │   "C:\fps.dll") │
  │                  │                │        ↓         │
  │                  │                │  ┌────────────┐  │
  │                  │                │  │ 我们的DLL  │  │
  │                  │                │  │ 被加载了！ │  │
  │                  │                │  │            │  │
  │                  │                │  │ DllMain()  │  │
  │                  │                │  │ 开始执行   │  │
  │                  │                │  └────────────┘  │
  │                  │                │                  │
  └──────────────────┘                └──────────────────┘
```

### 11.8 DLL 入口函数：DllMain

```cpp
// 当 DLL 被加载时，Windows 会自动调用这个函数
BOOL APIENTRY DllMain(HMODULE hModule, DWORD reason, LPVOID reserved) {
    switch (reason) {
        case DLL_PROCESS_ATTACH:
            // DLL 刚被加载到进程
            // 我们在这里启动 Hook 初始化
            CreateThread(NULL, 0, InitHook, hModule, 0, NULL);
            break;
            
        case DLL_PROCESS_DETACH:
            // DLL 即将被卸载
            // 我们在这里清理 Hook
            CleanupHook();
            break;
    }
    return TRUE;
}
```

### 11.9 权限问题

```
注入需要管理员权限！

因为：
- OpenProcess 需要 PROCESS_ALL_ACCESS
- 往别人进程写内存是敏感操作
- Windows 保护机制会阻止非管理员操作

所以：
- 我们的注入器需要"以管理员身份运行"
- 或者在 manifest 文件里声明需要管理员权限
```

### 11.10 类比总结

```
整个注入过程就像：

1. 你想在别人家里装一个摄像头（DLL）
2. 你先搞到别人家的钥匙（OpenProcess）
3. 在别人家借一个角落放纸条（VirtualAllocEx）
4. 纸条上写着摄像头藏在哪（WriteProcessMemory，DLL路径）
5. 你雇一个快递员进去（CreateRemoteThread）
6. 快递员按纸条找到摄像头并安装好（LoadLibrary）
7. 摄像头开始工作（DllMain 执行）
```

---

## 12. Hook 实现细节

### 12.1 什么是 Hook？

**Hook = 钩子 = 拦截函数调用，插入自己的代码**

```
正常调用：
游戏 ──────────────────────> 原始函数
         直接调用

Hook 之后：
游戏 ───────> 我们的函数 ───────> 原始函数
         先经过我们
```

**类比理解**：
> 想象你给朋友打电话：
>
> **正常情况**：
> ```
> 你 ────────────────> 朋友
>        直接接通
> ```
>
> **被 Hook 之后**：
> ```
> 你 ────> 中间人 ────> 朋友
>          │
>          └─> 中间人可以：
>              - 听你们说什么（监控）
>              - 修改你说的话（篡改）
>              - 假装朋友回复你（伪造）
>              - 记录通话时间（统计）
> ```

### 12.2 Hook 的两大类型

```
┌─────────────────────────────────────────────────────────────────┐
│                       Hook 类型                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────┐          ┌─────────────────────┐
│    Inline Hook      │          │    VTable Hook      │
│   （内联钩子）       │          │  （虚表钩子）        │
├─────────────────────┤          ├─────────────────────┤
│                     │          │                     │
│ 修改函数开头的      │          │ 修改虚函数表里的    │
│ 机器码指令          │          │ 函数指针            │
│                     │          │                     │
│ 适用于：普通函数    │          │ 适用于：C++ 虚函数  │
│                     │          │      COM 接口       │
│                     │          │      DirectX        │
└─────────────────────┘          └─────────────────────┘
         │                                │
         │                                │
         └───────────┬────────────────────┘
                     │
                     ▼
            我们两种都要用！
            - MinHook 做 Inline Hook
            - VTable 用于定位函数地址
```

### 12.3 Inline Hook 原理

#### 函数在内存中的样子

```
原始函数 MyFunction 在内存中：

地址        机器码              汇编指令
0x00401000  55                  push ebp
0x00401001  8B EC               mov ebp, esp
0x00401003  83 EC 10            sub esp, 0x10
0x00401006  ...                 ...（函数正文）
...
0x004010XX  C3                  ret
```

#### Inline Hook 的做法

```
修改函数开头，插入跳转指令：

修改前：
0x00401000  55                  push ebp
0x00401001  8B EC               mov ebp, esp
0x00401003  83 EC 10            sub esp, 0x10

修改后：
0x00401000  E9 XX XX XX XX      jmp 我们的函数地址
0x00401005  90                  nop（填充）
0x00401006  ...                 ...

当游戏调用 MyFunction 时：
1. 执行第一条指令：jmp 我们的函数
2. 跳转到我们的函数执行
3. 我们的函数可以选择调用原始函数
```

#### 图示

```
┌─────────────────────────────────────────────────────────────────┐
│                      Inline Hook 原理                            │
└─────────────────────────────────────────────────────────────────┘

原始函数                           我们的函数
┌────────────────┐               ┌────────────────┐
│ push ebp       │               │                │
│ mov ebp, esp   │  ═══════════> │  记录时间      │
│ sub esp, 0x10  │   被替换成    │  计算 FPS      │
│ ...            │   jmp 指令    │  渲染叠加层    │
│ ret            │               │                │
└────────────────┘               │  调用原始函数  │ ──┐
                                 │                │   │
                                 └────────────────┘   │
                                                      │
          ┌───────────────────────────────────────────┘
          │
          ▼
   Trampoline（跳板）
┌────────────────┐
│ push ebp       │  ← 保存被覆盖的原始指令
│ mov ebp, esp   │
│ sub esp, 0x10  │
│ jmp 原函数+6   │  ← 跳回原函数继续执行
└────────────────┘
```

### 12.4 MinHook 的工作原理

MinHook 帮我们自动完成 Inline Hook 的复杂工作：

```cpp
// 我们只需要这样写：
MH_CreateHook(
    原始函数地址,        // 要 Hook 的目标
    我们的函数,          // 替换成我们的函数
    &保存原始函数指针    // 保存原始函数，以便调用
);

// MinHook 内部做的事：
// 1. 分析原始函数开头的指令
// 2. 计算需要覆盖多少字节（至少5字节放 jmp）
// 3. 把被覆盖的指令复制到 Trampoline
// 4. 在原函数开头写入 jmp 指令
// 5. 返回 Trampoline 地址作为"原始函数"
```

### 12.5 VTable Hook 原理

#### 什么是 VTable？

```cpp
// C++ 虚函数的实现机制

class Animal {
public:
    virtual void Speak() { cout << "..."; }
    virtual void Move() { cout << "moving"; }
};

class Dog : public Animal {
public:
    void Speak() override { cout << "Woof!"; }
    void Move() override { cout << "running"; }
};
```

**编译器会为每个类创建一个虚函数表（VTable）**：

```
Dog 对象在内存中：
┌─────────────────────────────────┐
│  vptr (虚表指针)                │ ──────┐
├─────────────────────────────────┤       │
│  成员变量...                    │       │
└─────────────────────────────────┘       │
                                          │
                                          ▼
                                   Dog 的 VTable
                                   ┌─────────────────┐
                                   │ [0] Speak 地址  │ ──> Dog::Speak
                                   │ [1] Move 地址   │ ──> Dog::Move
                                   └─────────────────┘
```

#### DirectX 的接口也是这样

```
IDXGISwapChain 对象：
┌─────────────────────────────────┐
│  vptr                           │ ──────┐
├─────────────────────────────────┤       │
│  内部数据...                    │       │
└─────────────────────────────────┘       │
                                          │
                                          ▼
                               IDXGISwapChain 的 VTable
                               ┌──────────────────────────┐
                               │ [0] QueryInterface       │
                               │ [1] AddRef               │
                               │ [2] Release              │
                               │ ...                      │
                               │ [8] Present              │ ← 我们要 Hook！
                               │ ...                      │
                               │ [13] ResizeBuffers       │ ← 也要 Hook
                               │ ...                      │
                               └──────────────────────────┘
```

### 12.6 如何获取 VTable 中的函数地址

```cpp
// 从对象获取 VTable 函数地址
void* GetVTableFunction(void* pInterface, int index) {
    // pInterface 指向对象
    // 对象的第一个成员是 vptr（虚表指针）
    void** vptr = *(void***)pInterface;
    
    // vptr[index] 就是第 index 个虚函数的地址
    return vptr[index];
}

// 使用：
IDXGISwapChain* pSwapChain = ...;
void* pPresent = GetVTableFunction(pSwapChain, 8);  // Present 是第8个
```

### 12.7 为什么需要创建 Dummy SwapChain？

```
问题：我们的 DLL 刚注入时，游戏已经创建了 SwapChain
     但我们不知道它在哪里！

解决方案：自己创建一个临时的 SwapChain，用来获取函数地址

原理：同一个类的所有对象共享同一个 VTable
     所以我们创建的临时 SwapChain 和游戏的 SwapChain
     它们的 Present 函数地址是一样的！
```

### 12.8 完整 Hook 流程

```
┌─────────────────────────────────────────────────────────────────┐
│                     完整 Hook 流程                               │
└─────────────────────────────────────────────────────────────────┘

步骤1：创建 Dummy SwapChain
┌───────────────────────────────┐
│ D3D11CreateDeviceAndSwapChain │
│            │                  │
│            ▼                  │
│   pDummySwapChain             │
└───────────────────────────────┘
            │
            │ 获取 VTable
            ▼
步骤2：从 VTable 获取函数地址
┌───────────────────────────────┐
│ VTable[8]  ──> Present 地址   │
│ VTable[13] ──> ResizeBuffers  │
└───────────────────────────────┘
            │
            │ 使用 MinHook
            ▼
步骤3：安装 Inline Hook
┌───────────────────────────────┐
│ MH_CreateHook(Present, ...)   │
│ MH_CreateHook(ResizeBuffers)  │
│ MH_EnableHook(MH_ALL_HOOKS)   │
└───────────────────────────────┘
            │
            │ 释放临时资源
            ▼
步骤4：销毁 Dummy SwapChain
┌───────────────────────────────┐
│ pDummySwapChain->Release()    │
│ （不再需要它了）               │
└───────────────────────────────┘
            │
            │ Hook 已生效
            ▼
步骤5：游戏调用 Present 时
┌───────────────────────────────┐
│ 游戏的 Present 调用           │
│        │                      │
│        ▼                      │
│ 跳转到我们的 HookPresent      │
│        │                      │
│        ▼                      │
│ 我们计算 FPS、渲染叠加层      │
│        │                      │
│        ▼                      │
│ 调用原始 Present              │
└───────────────────────────────┘
```

### 12.9 关键注意事项

| 注意事项 | 说明 |
|----------|------|
| **调用约定** | DirectX 使用 `__stdcall`，必须匹配 |
| **线程安全** | Present 在渲染线程调用，初始化要注意线程安全 |
| **异常处理** | Hook 函数里不能抛异常，否则游戏崩溃 |
| **原函数调用** | 最后必须调用原始 Present，否则画面不显示 |
| **资源管理** | 获取的设备、上下文要正确释放 |

---

## 13. ImGui 集成方式

### 13.1 什么是 ImGui？

**ImGui = Immediate Mode GUI（即时模式图形界面）**

```
传统 GUI（保留模式）：
- 创建按钮对象
- 按钮一直存在内存中
- 修改按钮需要找到对象再修改

ImGui（即时模式）：
- 每帧都重新"画"一个按钮
- 不保存按钮对象
- 代码即界面，简单直接
```

### 13.2 ImGui 代码风格

```cpp
// 传统 GUI（如 Qt、WinForms）
Button* btn = new Button("点击我");
btn->setPosition(100, 100);
btn->onClick = []() { doSomething(); };
window->addChild(btn);

// ImGui 风格
if (ImGui::Button("点击我")) {
    doSomething();  // 按钮被点击时执行
}
// 就这么简单！每帧都执行这段代码
// ImGui 自动处理绘制、点击检测等
```

### 13.3 为什么选择 ImGui？

| 优点 | 说明 |
|------|------|
| **轻量** | 几个 .cpp/.h 文件，无额外依赖 |
| **易集成** | 支持 DirectX 9/10/11/12、OpenGL、Vulkan |
| **游戏圈标配** | 游戏调试工具、模组、外挂都用它 |
| **简单** | 代码即界面，几行代码就能画东西 |
| **高效** | 专为每帧重绘设计，性能优异 |

### 13.4 ImGui 需要的文件

```
从 ImGui 仓库下载这些文件：

imgui/
├── imgui.cpp              # 核心
├── imgui.h                # 核心头文件
├── imgui_draw.cpp         # 绘制
├── imgui_tables.cpp       # 表格
├── imgui_widgets.cpp      # 控件
├── imgui_internal.h       # 内部头文件
├── imconfig.h             # 配置
│
├── backends/
│   ├── imgui_impl_win32.cpp   # Windows 平台后端
│   ├── imgui_impl_win32.h
│   ├── imgui_impl_dx11.cpp    # DirectX 11 渲染后端
│   └── imgui_impl_dx11.h
```

### 13.5 ImGui 架构

```
┌─────────────────────────────────────────────────────────────────┐
│                       ImGui 架构                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      你的代码                                    │
│                                                                 │
│   ImGui::Begin("窗口");                                         │
│   ImGui::Text("FPS: %.1f", fps);                                │
│   ImGui::End();                                                 │
│                                                                 │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                    ImGui 核心                                    │
│                                                                 │
│   - 布局计算                                                    │
│   - 控件状态管理                                                │
│   - 生成绘制命令列表                                            │
│                                                                 │
└───────────────────────────┬─────────────────────────────────────┘
                            │
              ┌─────────────┴─────────────┐
              ▼                           ▼
┌─────────────────────────┐   ┌─────────────────────────┐
│   平台后端               │   │   渲染后端              │
│   imgui_impl_win32      │   │   imgui_impl_dx11       │
│                         │   │                         │
│   - 处理输入（键鼠）     │   │   - 创建顶点缓冲        │
│   - 处理窗口消息        │   │   - 创建着色器          │
│   - 光标管理            │   │   - 执行绘制命令        │
│                         │   │                         │
└─────────────────────────┘   └────────────┬────────────┘
                                           │
                                           ▼
                              ┌─────────────────────────┐
                              │      DirectX 11        │
                              │      GPU 渲染          │
                              └─────────────────────────┘
```

### 13.6 ImGui 集成步骤

#### 步骤1：初始化

```cpp
bool InitImGui(HWND hWnd, ID3D11Device* pDevice, ID3D11DeviceContext* pContext) {
    // 1. 创建 ImGui 上下文
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    
    // 2. 获取 IO 对象（输入输出配置）
    ImGuiIO& io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange;
    
    // 3. 设置样式
    ImGui::StyleColorsDark();
    
    // 4. 初始化平台后端（处理输入）
    ImGui_ImplWin32_Init(hWnd);
    
    // 5. 初始化渲染后端（DirectX 11）
    ImGui_ImplDX11_Init(pDevice, pContext);
    
    return true;
}
```

#### 步骤2：每帧渲染

```cpp
void RenderOverlay() {
    // 1. 开始新帧
    ImGui_ImplDX11_NewFrame();
    ImGui_ImplWin32_NewFrame();
    ImGui::NewFrame();
    
    // 2. 绘制界面
    DrawFPSOverlay();
    
    // 3. 结束帧并渲染
    ImGui::Render();
    ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
}
```

#### 步骤3：清理

```cpp
void ShutdownImGui() {
    ImGui_ImplDX11_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();
}
```

### 13.7 绘制 FPS 叠加层示例

```cpp
void DrawFPSOverlay() {
    // 设置窗口属性
    ImGui::SetNextWindowPos(ImVec2(10, 10), ImGuiCond_FirstUseEver);
    ImGui::SetNextWindowSize(ImVec2(150, 60), ImGuiCond_FirstUseEver);
    ImGui::SetNextWindowBgAlpha(0.6f);  // 半透明背景
    
    // 窗口标志：无标题栏、不可移动、不可调整大小
    ImGuiWindowFlags flags = 
        ImGuiWindowFlags_NoTitleBar |
        ImGuiWindowFlags_NoResize |
        ImGuiWindowFlags_NoMove |
        ImGuiWindowFlags_NoScrollbar |
        ImGuiWindowFlags_NoInputs;  // 点击穿透
    
    if (ImGui::Begin("FPS Overlay", nullptr, flags)) {
        float fps = GetCurrentFPS();
        
        // 根据 FPS 选择颜色
        ImVec4 color;
        if (fps >= 60.0f) {
            color = ImVec4(0.0f, 1.0f, 0.0f, 1.0f);  // 绿色
        } else if (fps >= 30.0f) {
            color = ImVec4(1.0f, 1.0f, 0.0f, 1.0f);  // 黄色
        } else {
            color = ImVec4(1.0f, 0.0f, 0.0f, 1.0f);  // 红色
        }
        
        ImGui::TextColored(color, "FPS: %.1f", fps);
        ImGui::Text("Frame: %.2f ms", GetFrameTime());
    }
    ImGui::End();
}
```

### 13.8 处理窗口消息（输入）

```cpp
// 原始窗口过程
WNDPROC OriginalWndProc = nullptr;

// 我们的窗口过程
LRESULT CALLBACK HookWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    // 先让 ImGui 处理消息
    if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam)) {
        return true;
    }
    
    // 处理热键（F1 切换显示）
    if (msg == WM_KEYDOWN && wParam == VK_F1) {
        g_showOverlay = !g_showOverlay;
    }
    
    // 传递给原始窗口过程
    return CallWindowProc(OriginalWndProc, hWnd, msg, wParam, lParam);
}

// 安装窗口过程 Hook
void HookWindowProc(HWND hWnd) {
    OriginalWndProc = (WNDPROC)SetWindowLongPtr(
        hWnd, GWLP_WNDPROC, (LONG_PTR)HookWndProc
    );
}
```

### 13.9 处理窗口大小变化

```cpp
// Hook ResizeBuffers 处理窗口大小变化
HRESULT __stdcall HookResizeBuffers(...) {
    // 1. 释放旧资源
    if (g_pRenderTargetView) {
        g_pRenderTargetView->Release();
        g_pRenderTargetView = nullptr;
    }
    ImGui_ImplDX11_InvalidateDeviceObjects();
    
    // 2. 调用原始函数
    HRESULT hr = OriginalResizeBuffers(...);
    
    // 3. 重建资源
    CreateRenderTarget(pSwapChain);
    ImGui_ImplDX11_CreateDeviceObjects();
    
    return hr;
}
```

### 13.10 ImGui 常用控件

```cpp
// 文本
ImGui::Text("普通文本");
ImGui::TextColored(ImVec4(1,0,0,1), "红色文本");

// 按钮
if (ImGui::Button("点击我")) { /* 处理点击 */ }

// 复选框
static bool checked = false;
ImGui::Checkbox("选项", &checked);

// 滑块
static float value = 0.5f;
ImGui::SliderFloat("数值", &value, 0.0f, 1.0f);

// 颜色选择器
static float color[3] = {1.0f, 0.0f, 0.0f};
ImGui::ColorEdit3("颜色", color);
```

---

## 14. 调试技巧

### 14.1 调试注入 DLL 的挑战

```
普通程序调试：
  Visual Studio ──> 启动程序 ──> 断点生效 ✅

注入 DLL 调试：
  DLL 不能独立运行！
  DLL 被注入到游戏进程
  游戏不是我们启动的
  需要特殊调试方法
```

### 14.2 调试方法总览

| 方法 | 难度 | 适用场景 |
|------|------|----------|
| **日志输出** | ⭐ 简单 | 所有场景，最常用 |
| **附加到进程** | ⭐⭐ 中等 | 需要断点调试时 |
| **MessageBox 暂停** | ⭐ 简单 | 快速定位崩溃点 |
| **异常捕获** | ⭐⭐ 中等 | 捕获崩溃原因 |

### 14.3 方法1：日志输出（最常用）

#### OutputDebugString

```cpp
void DebugLog(const char* format, ...) {
    char buffer[1024];
    va_list args;
    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);
    
    OutputDebugStringA(buffer);
}

// 使用
DebugLog("[FPS Overlay] Present called, FPS: %.2f\n", fps);
```

#### 用 DebugView 查看

```
下载 DebugView（微软 Sysinternals 工具）

┌─────────────────────────────────────────────────────────────────┐
│                        DebugView                                │
├─────────────────────────────────────────────────────────────────┤
│  [12:34:56] [FPS Overlay] DLL Loaded                           │
│  [12:34:56] [FPS Overlay] Hook installed successfully          │
│  [12:34:57] [FPS Overlay] Present called, FPS: 60.12           │
└─────────────────────────────────────────────────────────────────┘
```

#### 写入文件日志

```cpp
class Logger {
    std::ofstream file;
    std::mutex mtx;
public:
    Logger() {
        file.open("C:\\fps_overlay_log.txt", std::ios::app);
    }
    
    void Log(const char* format, ...) {
        std::lock_guard<std::mutex> lock(mtx);
        // 写入时间戳和消息
        file << "[时间] " << 消息 << std::endl;
        file.flush();  // 立即写入，防止崩溃时丢失
    }
};
```

### 14.4 方法2：附加调试器到进程

```
步骤：

1. 启动游戏（不用调试器）
2. 运行注入器，把 DLL 注入到游戏
3. 在 Visual Studio 中：
   调试 → 附加到进程 → 选择游戏进程
4. 现在可以在 DLL 代码中设置断点了
```

### 14.5 方法3：MessageBox 暂停

```cpp
void InitHook() {
    // 弹出消息框，暂停执行
    // 这时可以附加调试器
    MessageBoxA(NULL, "现在可以附加调试器", "Debug", MB_OK);
    
    // 点击确定后继续执行
    // ... Hook 代码 ...
}
```

### 14.6 方法4：异常捕获

```cpp
LONG WINAPI CrashHandler(EXCEPTION_POINTERS* ep) {
    // 记录崩溃信息
    Log("!!! CRASH !!!");
    Log("Exception Code: 0x%08X", ep->ExceptionRecord->ExceptionCode);
    Log("Exception Address: %p", ep->ExceptionRecord->ExceptionAddress);
    
    MessageBoxA(NULL, "崩溃！请查看日志", "Crash", MB_OK);
    return EXCEPTION_CONTINUE_SEARCH;
}

void InstallCrashHandler() {
    SetUnhandledExceptionFilter(CrashHandler);
}
```

### 14.7 常见问题排查

#### DLL 没有被加载

```
检查清单：
□ 注入器是否以管理员权限运行？
□ DLL 路径是否正确？
□ DLL 是 32 位还是 64 位？必须和游戏匹配！
□ 是否缺少依赖的 DLL？
```

#### Hook 失败

```
检查 MinHook 返回值：
MH_ERROR_NOT_INITIALIZED = -1  → 忘记调用 MH_Initialize
MH_ERROR_ALREADY_CREATED = -2  → 重复创建 Hook
MH_ERROR_NOT_EXECUTABLE = -3   → 目标地址不可执行
```

#### 游戏崩溃

```
常见原因：
1. 调用约定不匹配（应该用 __stdcall）
2. 忘记调用原始函数
3. 空指针访问
4. 在错误的线程调用 DirectX
```

### 14.8 调试检查清单

```
┌─────────────────────────────────────────────────────────────────┐
│                        调试检查清单                              │
└─────────────────────────────────────────────────────────────────┘

□ DLL 加载阶段
  □ DllMain 被调用？
  □ 32/64 位匹配？

□ Hook 阶段
  □ Dummy SwapChain 创建成功？
  □ MH_Initialize 返回 MH_OK？
  □ MH_CreateHook 返回 MH_OK？
  □ MH_EnableHook 返回 MH_OK？

□ 渲染阶段
  □ Hook 函数被调用？
  □ Device/Context 获取成功？
  □ ImGui 初始化成功？
  □ 原始 Present 被调用？
```

### 14.9 调试工具推荐

| 工具 | 用途 |
|------|------|
| **DebugView** | 查看 OutputDebugString |
| **Process Explorer** | 查看进程加载的 DLL |
| **x64dbg** | 独立调试器 |
| **RenderDoc** | DirectX 帧分析 |
